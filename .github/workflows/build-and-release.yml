name: Build and Release

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build-and-release:
    runs-on: windows-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for tags

    - name: Get latest tag
      id: get_tag
      run: |
        $latestTag = git describe --tags --abbrev=0 2>$null
        if (-not $latestTag) {
          $latestTag = "v0.0.0"
        }
        echo "current_tag=$latestTag" >> $env:GITHUB_OUTPUT
        echo "Current tag: $latestTag"

    - name: Determine version bump
      id: version_bump
      run: |
        $commitMsg = git log -1 --pretty=%B
        echo "Commit message: $commitMsg"

        $currentTag = "${{ steps.get_tag.outputs.current_tag }}"
        $version = $currentTag -replace '^v', ''
        $parts = $version -split '\.'
        $major = [int]$parts[0]
        $minor = [int]$parts[1]
        $patch = [int]$parts[2]

        $shouldRelease = $false

        if ($commitMsg -match '^major:') {
          $major++
          $minor = 0
          $patch = 0
          $shouldRelease = $true
          echo "Bump type: MAJOR"
        }
        elseif ($commitMsg -match '^feat:') {
          $minor++
          $patch = 0
          $shouldRelease = $true
          echo "Bump type: MINOR (feat)"
        }
        elseif ($commitMsg -match '^fix:') {
          $patch++
          $shouldRelease = $true
          echo "Bump type: PATCH (fix)"
        }
        else {
          echo "No version bump needed (commit message doesn't start with fix:, feat:, or major:)"
        }

        $newVersion = "v$major.$minor.$patch"
        echo "new_version=$newVersion" >> $env:GITHUB_OUTPUT
        echo "should_release=$shouldRelease" >> $env:GITHUB_OUTPUT
        echo "New version: $newVersion"
        echo "Should release: $shouldRelease"

    - name: Create tag
      if: steps.version_bump.outputs.should_release == 'true'
      run: |
        $newVersion = "${{ steps.version_bump.outputs.new_version }}"
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag -a $newVersion -m "Release $newVersion"
        git push origin $newVersion
        echo "Created and pushed tag: $newVersion"

    - name: Set up Python
      if: steps.version_bump.outputs.should_release == 'true'
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install dependencies
      if: steps.version_bump.outputs.should_release == 'true'
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pyinstaller

    - name: Update version.py with release version
      if: steps.version_bump.outputs.should_release == 'true'
      shell: python
      run: |
        version = "${{ steps.version_bump.outputs.new_version }}".lstrip("v")
        parts = version.split(".")
        content = f'''"""
        Version information for Thermal Engine.
        This file is automatically updated by the build process.
        """

        __version__ = "{version}"
        __version_info__ = ({parts[0]}, {parts[1]}, {parts[2]})

        def get_version():
            """Get the current version string."""
            return __version__

        def get_version_tuple():
            """Get the current version as a tuple."""
            return __version_info__
        '''
        lines = [line.lstrip() for line in content.strip().splitlines()]
        with open("version.py", "w") as f:
            f.write("\n".join(lines) + "\n")
        print(f"Updated version.py to {version}")
        with open("version.py") as f:
            print(f.read())

    - name: Download libusb DLLs
      if: steps.version_bump.outputs.should_release == 'true'
      run: |
        # Download libusb for Windows (needed for USB device access)
        Invoke-WebRequest -Uri "https://github.com/libusb/libusb/releases/download/v1.0.27/libusb-1.0.27.7z" -OutFile "libusb.7z"
        7z x libusb.7z -olibusb
        # Copy the 64-bit DLL to a location PyInstaller will find
        Copy-Item "libusb\VS2019\MS64\dll\libusb-1.0.dll" -Destination "." -Force
        echo "libusb-1.0.dll downloaded and ready"

    - name: Build with PyInstaller
      if: steps.version_bump.outputs.should_release == 'true'
      run: |
        pyinstaller --name="ThermalEngine" `
          --onedir `
          --windowed `
          --icon="assets/icon.ico" `
          --add-data="elements;elements" `
          --add-data="assets;assets" `
          --add-data="presets;presets" `
          --add-binary="libusb-1.0.dll;." `
          --hidden-import=PySide6.QtCore `
          --hidden-import=PySide6.QtGui `
          --hidden-import=PySide6.QtWidgets `
          --hidden-import=device_backends `
          --hidden-import=video_background `
          --collect-submodules=device_backends `
          --hidden-import=usb `
          --hidden-import=usb.core `
          --hidden-import=usb.backend `
          --hidden-import=usb.backend.libusb1 `
          --collect-submodules=usb `
          --collect-binaries=usb `
          --collect-data=usb `
          --exclude-module=tkinter `
          --exclude-module=matplotlib `
          --exclude-module=pandas `
          --exclude-module=scipy `
          --exclude-module=PySide6.QtNetwork `
          --exclude-module=PySide6.QtQml `
          --exclude-module=PySide6.QtQuick `
          --exclude-module=PySide6.QtWebEngineWidgets `
          --exclude-module=PySide6.Qt3D `
          --exclude-module=PySide6.QtCharts `
          --exclude-module=PySide6.QtDataVisualization `
          main.py

    - name: Install Inno Setup
      if: steps.version_bump.outputs.should_release == 'true'
      run: |
        # Install Inno Setup via Chocolatey (pre-installed on GitHub runners)
        choco install innosetup -y --no-progress
        echo "Inno Setup installed"

    - name: Build Installer
      if: steps.version_bump.outputs.should_release == 'true'
      run: |
        $version = "${{ steps.version_bump.outputs.new_version }}"
        # Remove 'v' prefix from version for installer
        $versionNum = $version -replace '^v', ''

        # Compile installer with Inno Setup
        & "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" `
          /DMyAppVersion=$versionNum `
          installer.iss

        # Find the generated installer
        $installerName = "ThermalEngine-$versionNum-Setup.exe"
        if (Test-Path $installerName) {
          $finalName = "ThermalEngine-$version-Setup.exe"
          Move-Item $installerName $finalName -Force
          echo "installer_name=$finalName" >> $env:GITHUB_OUTPUT
          echo "Created installer: $finalName"
        } else {
          echo "ERROR: Installer not found at $installerName"
          exit 1
        }
      id: build_installer

    - name: Generate changelog
      if: steps.version_bump.outputs.should_release == 'true'
      id: changelog
      shell: python
      run: |
        import subprocess, re

        current_tag = "${{ steps.get_tag.outputs.current_tag }}"
        new_version = "${{ steps.version_bump.outputs.new_version }}"

        # Get commits between previous tag and HEAD
        result = subprocess.run(
            ["git", "log", f"{current_tag}..HEAD", "--pretty=format:%s"],
            capture_output=True, text=True
        )
        commits = result.stdout.strip().split("\n") if result.stdout.strip() else []

        features = []
        fixes = []
        breaking = []
        other = []

        for msg in commits:
            msg = msg.strip()
            if not msg:
                continue

            # Extract description after prefix
            if msg.startswith("major:"):
                desc = msg[len("major:"):].strip()
                breaking.append(desc)
            elif msg.startswith("feat:"):
                desc = msg[len("feat:"):].strip()
                features.append(desc)
            elif msg.startswith("fix:"):
                desc = msg[len("fix:"):].strip()
                fixes.append(desc)
            else:
                other.append(msg)

        # Build changelog
        lines = [f"## What's Changed in {new_version}\n"]

        if breaking:
            lines.append("### Breaking Changes")
            for item in breaking:
                lines.append(f"- {item}")
            lines.append("")

        if features:
            lines.append("### New Features")
            for item in features:
                lines.append(f"- {item}")
            lines.append("")

        if fixes:
            lines.append("### Bug Fixes & Improvements")
            for item in fixes:
                lines.append(f"- {item}")
            lines.append("")

        if other:
            lines.append("### Other Changes")
            for item in other:
                lines.append(f"- {item}")
            lines.append("")

        changelog = "\n".join(lines)
        print(changelog)

        # Write to file for the release step
        with open("CHANGELOG.md", "w", encoding="utf-8") as f:
            f.write(changelog)

    - name: Create Release
      if: steps.version_bump.outputs.should_release == 'true'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.version_bump.outputs.new_version }}
        name: Release ${{ steps.version_bump.outputs.new_version }}
        draft: false
        prerelease: false
        files: ${{ steps.build_installer.outputs.installer_name }}
        body_path: CHANGELOG.md
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Upload artifact
      if: steps.version_bump.outputs.should_release == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: ThermalEngine-${{ steps.version_bump.outputs.new_version }}-Installer
        path: ${{ steps.build_installer.outputs.installer_name }}
